/**
 * iOS localization service for app name management
 */

import * as vscode from 'vscode';
import * as path from 'path';

/**
 * Gets the InfoPlist.strings file URI for a specific language
 * @param workspaceRoot - Workspace root URI
 * @param languageCode - Language code (e.g., 'en', 'ar')
 * @returns URI to the InfoPlist.strings file
 */
export async function getInfoPlistStringsFile(
    workspaceRoot: vscode.Uri,
    languageCode: string
): Promise<vscode.Uri | undefined> {
    const lprojDir = `${languageCode}.lproj`;
    const runnerPath = vscode.Uri.joinPath(workspaceRoot, 'ios', 'Runner');
    const stringsPath = vscode.Uri.joinPath(runnerPath, lprojDir, 'InfoPlist.strings');
    
    try {
        await vscode.workspace.fs.stat(stringsPath);
        return stringsPath;
    } catch {
        return undefined;
    }
}

/**
 * Creates a new InfoPlist.strings file for a specific language
 * @param workspaceRoot - Workspace root URI
 * @param languageCode - Language code (e.g., 'en', 'ar')
 * @returns URI to the created InfoPlist.strings file
 */
export async function createInfoPlistStringsFile(
    workspaceRoot: vscode.Uri,
    languageCode: string
): Promise<vscode.Uri | undefined> {
    const lprojDir = `${languageCode}.lproj`;
    const runnerPath = vscode.Uri.joinPath(workspaceRoot, 'ios', 'Runner');
    const lprojPath = vscode.Uri.joinPath(runnerPath, lprojDir);
    const stringsPath = vscode.Uri.joinPath(lprojPath, 'InfoPlist.strings');
    
    try {
        // Ensure the .lproj directory exists
        try {
            await vscode.workspace.fs.stat(lprojPath);
        } catch {
            await vscode.workspace.fs.createDirectory(lprojPath);
        }
        
        // Create default content
        const defaultContent = `/* 
  InfoPlist.strings
  Runner

  Generated by Flutter Config Manager.
*/

"CFBundleDisplayName" = "App";
"CFBundleName" = "App";
`;
        await vscode.workspace.fs.writeFile(stringsPath, Buffer.from(defaultContent, 'utf-8'));
        return stringsPath;
    } catch (error) {
        console.error(`Failed to create InfoPlist.strings for ${languageCode}:`, error);
        return undefined;
    }
}

/**
 * Extracts the app name from InfoPlist.strings content
 * @param stringsContent - Content of InfoPlist.strings
 * @returns The app name value or undefined if not found
 */
export function extractAppNameFromInfoPlistStrings(stringsContent: string): string | undefined {
    // Look for CFBundleDisplayName
    const regex = /"CFBundleDisplayName"\s*=\s*"([^"]+)";/i;
    const match = stringsContent.match(regex);
    return match?.[1];
}

/**
 * Updates the app name in InfoPlist.strings content
 * @param stringsContent - Content of InfoPlist.strings
 * @param appName - New app name value
 * @returns Updated content
 */
export function updateAppNameInInfoPlistStrings(stringsContent: string, appName: string): string {
    // Update CFBundleDisplayName
    const displayNameRegex = /"CFBundleDisplayName"\s*=\s*"[^"]*";/i;
    if (displayNameRegex.test(stringsContent)) {
        stringsContent = stringsContent.replace(displayNameRegex, `"CFBundleDisplayName" = "${appName}";`);
    } else {
        // Add CFBundleDisplayName
        stringsContent += `\n"CFBundleDisplayName" = "${appName}";`;
    }
    
    // Update CFBundleName
    const bundleNameRegex = /"CFBundleName"\s*=\s*"[^"]*";/i;
    if (bundleNameRegex.test(stringsContent)) {
        stringsContent = stringsContent.replace(bundleNameRegex, `"CFBundleName" = "${appName}";`);
    } else {
        // Add CFBundleName
        stringsContent += `\n"CFBundleName" = "${appName}";`;
    }
    
    return stringsContent;
}

/**
 * Extracts the app name from Info.plist
 * @param plistContent - Content of Info.plist
 * @returns The app name value or undefined if not found
 */
export function extractAppNameFromInfoPlist(plistContent: string): { displayName?: string; bundleName?: string } {
    const result: { displayName?: string; bundleName?: string } = {};
    
    // Extract CFBundleDisplayName
    const displayNameRegex = /<key>CFBundleDisplayName<\/key>\s*<string>([^<]*)<\/string>/i;
    const displayMatch = plistContent.match(displayNameRegex);
    if (displayMatch?.[1]) {
        result.displayName = displayMatch[1];
    }
    
    // Extract CFBundleName
    const bundleNameRegex = /<key>CFBundleName<\/key>\s*<string>([^<]*)<\/string>/i;
    const bundleMatch = plistContent.match(bundleNameRegex);
    if (bundleMatch?.[1]) {
        result.bundleName = bundleMatch[1];
    }
    
    return result;
}

/**
 * Updates Info.plist to use localized strings for app name
 * This replaces hardcoded strings with references to InfoPlist.strings
 * @param plistContent - Content of Info.plist
 * @returns Updated content
 */
export function updateInfoPlistToUseLocalizedAppName(plistContent: string): string {
    // Replace CFBundleDisplayName hardcoded value with placeholder that triggers localization
    const displayNameRegex = /(<key>CFBundleDisplayName<\/key>\s*<string>)([^<$][^<]*)(<\/string>)/i;
    if (displayNameRegex.test(plistContent)) {
        plistContent = plistContent.replace(displayNameRegex, '$1$(PRODUCT_NAME)$3');
    }
    
    // Replace CFBundleName hardcoded value with placeholder
    const bundleNameRegex = /(<key>CFBundleName<\/key>\s*<string>)([^<$][^<]*)(<\/string>)/i;
    if (bundleNameRegex.test(plistContent)) {
        plistContent = plistContent.replace(bundleNameRegex, '$1$(PRODUCT_NAME)$3');
    }
    
    // Also update FacebookDisplayName if present
    const fbDisplayNameRegex = /(<key>FacebookDisplayName<\/key>\s*<string>)([^<$][^<]*)(<\/string>)/i;
    if (fbDisplayNameRegex.test(plistContent)) {
        // Keep Facebook display name hardcoded or could reference a different key
        // For now, we leave it as is since it's typically the same across languages
    }
    
    return plistContent;
}

/**
 * Gets all available language codes from the Runner directory
 * @param workspaceRoot - Workspace root URI
 * @returns Array of language codes
 */
export async function getAvailableLanguages(
    workspaceRoot: vscode.Uri
): Promise<string[]> {
    const runnerPath = vscode.Uri.joinPath(workspaceRoot, 'ios', 'Runner');
    const languages: string[] = [];
    
    try {
        const entries = await vscode.workspace.fs.readDirectory(runnerPath);
        
        for (const [name, type] of entries) {
            if (type === vscode.FileType.Directory && name.endsWith('.lproj')) {
                const langCode = name.replace('.lproj', '');
                languages.push(langCode);
            }
        }
    } catch (error) {
        console.error('Failed to read Runner directory:', error);
    }
    
    return languages;
}

/**
 * Updates app name localizations for iOS
 * Creates/modifies InfoPlist.strings files for each language
 * @param workspaceRoot - Workspace root URI
 * @param localizations - Record of language code to app name
 * @param defaultName - Default app name for fallback
 */
export async function updateIOSAppNameLocalizations(
    workspaceRoot: vscode.Uri,
    localizations: Record<string, string>,
    defaultName: string
): Promise<void> {
    // Ensure we have at least English localization (default)
    let defaultStringsUri = await getInfoPlistStringsFile(workspaceRoot, 'en');
    if (!defaultStringsUri) {
        defaultStringsUri = await createInfoPlistStringsFile(workspaceRoot, 'en');
    }
    
    if (defaultStringsUri) {
        // Update default app name
        const doc = await vscode.workspace.openTextDocument(defaultStringsUri);
        let content = doc.getText();
        content = updateAppNameInInfoPlistStrings(content, defaultName);
        await vscode.workspace.fs.writeFile(defaultStringsUri, Buffer.from(content, 'utf-8'));
    }
    
    // Update/create localized InfoPlist.strings files
    for (const [langCode, appName] of Object.entries(localizations)) {
        if (langCode === 'en') { continue; } // Already handled above
        
        let stringsUri = await getInfoPlistStringsFile(workspaceRoot, langCode);
        if (!stringsUri) {
            stringsUri = await createInfoPlistStringsFile(workspaceRoot, langCode);
        }
        
        if (stringsUri) {
            const doc = await vscode.workspace.openTextDocument(stringsUri);
            let content = doc.getText();
            content = updateAppNameInInfoPlistStrings(content, appName);
            await vscode.workspace.fs.writeFile(stringsUri, Buffer.from(content, 'utf-8'));
        }
    }
}

/**
 * Extracts all localized app names from iOS project
 * @param workspaceRoot - Workspace root URI
 * @returns Record of language codes to app names
 */
export async function extractIOSAppNameLocalizations(
    workspaceRoot: vscode.Uri
): Promise<{ defaultName: string; localizations: Record<string, string> } | undefined> {
    const localizations: Record<string, string> = {};
    let defaultName: string | undefined;
    
    // Get default app name from en.lproj/InfoPlist.strings
    const defaultStringsUri = await getInfoPlistStringsFile(workspaceRoot, 'en');
    if (defaultStringsUri) {
        const doc = await vscode.workspace.openTextDocument(defaultStringsUri);
        defaultName = extractAppNameFromInfoPlistStrings(doc.getText());
    }
    
    // If no InfoPlist.strings, try reading from Info.plist directly
    if (!defaultName) {
        try {
            const plistPath = vscode.Uri.joinPath(workspaceRoot, 'ios', 'Runner', 'Info.plist');
            const doc = await vscode.workspace.openTextDocument(plistPath);
            const appNames = extractAppNameFromInfoPlist(doc.getText());
            defaultName = appNames.displayName || appNames.bundleName;
        } catch (error) {
            console.error('Failed to read Info.plist:', error);
        }
    }
    
    // Get all available languages
    const languages = await getAvailableLanguages(workspaceRoot);
    
    // Extract app names for each language
    for (const langCode of languages) {
        if (langCode === 'en') { continue; } // Default is handled above
        
        const stringsUri = await getInfoPlistStringsFile(workspaceRoot, langCode);
        if (stringsUri) {
            const doc = await vscode.workspace.openTextDocument(stringsUri);
            const appName = extractAppNameFromInfoPlistStrings(doc.getText());
            if (appName) {
                localizations[langCode] = appName;
            }
        }
    }
    
    if (!defaultName) {
        return undefined;
    }
    
    return { defaultName, localizations };
}
